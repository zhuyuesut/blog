---
layout: post
author: Zhu Yue
---
> PS: 偶见一游戏，特发此博客留念。

0在这十句话里出现的次数是（ ）；
1在这十句话里出现的次数是（ ）；
2在这十句话里出现的次数是（ ）；
3在这十句话里出现的次数是（ ）；
4在这十句话里出现的次数是（ ）；
5在这十句话里出现的次数是（ ）；
6在这十句话里出现的次数是（ ）；
7在这十句话里出现的次数是（ ）；
8在这十句话里出现的次数是（ ）；
9在这十句话里出现的次数是（ ）；

著作权归作者所有。
商业转载请联系作者获得授权，非商业转载请注明出处。
作者：谢平凡
链接：http://www.zhihu.com/question/20720161/answer/15962448
来源：知乎

1732111211，被抢先了:)  
条件1：右边一列数字加起来只能等于20；因为这些句子里数字只出现了20次。  
条件2：0出现了1次；因为其他数字都至少出现过一次。  
根据条件1，56789那些大数字最多只有一个出现两次（两个两次就爆表）。  
所以1出现了n次；所以n出现了2次；  
2至少出现了2次，但是不能仅有2次（2后写2，就有3个2了）所以2出现了m次；  
由于n很大，m不能太大，不能超过10-n（否则爆表）  
假如m=3，那么3出现2次，n=7，结果是1732111211  
假如m=4，容易验证无解。  
综上，1732111211是唯一解。  


每个数字至少出现1次, 一共 20 个数字, 所以填的数字的和是 20, 有了这两个条件, 就好办了: def check seq 0.upto 9 do |i| return false if seq.count(i) + 1 != seq[i] end true end def calc seq, rest_sum if seq.size == 10 p seq if rest_sum == 0 and check seq else 1.upto 9 do |i| break if rest_sum < i calc seq + [i], rest_sum - i end end end calc [], 20
去掉这个要求是可以的... 不过总次数变成最多 20, 去掉这个要求而修改的程序如下 def calc seq, rest_sum if seq.size == 10 p seq if rest_sum == seq.count{|i|i>9} and (0..9).all?{|i| seq.count(i) + 1 == seq[i]} else 1.upto 10 do |i| break if rest_sum < i calc seq + [i], rest_sum - i end end end calc [], 20 $ ruby sum.rb [1, 7, 3, 2, 1, 1, 1, 2, 1, 1] [1, 10, 1, 1, 1, 1, 1, 1, 1, 1]

你们都是大牛... #15楼 @chyanog 我也照着写了个 ruby 版的 integer partition # "隔板法" 求 partition ... def int_partition sum, n (1...sum).to_a.combination(n - 1).each do |c| yield [0, *c, sum].each_cons(2).map{|x, y| y - x} end end int_partition 20, 10 do |s| p s if (0..9).all?{|i| s.count(i) + 1 == s[i] } end